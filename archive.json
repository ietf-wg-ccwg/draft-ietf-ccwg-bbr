{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-12-05T01:36:25.400478+00:00",
  "repo": "ietf-wg-ccwg/draft-ietf-ccwg-bbr",
  "labels": [
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "Editorial",
      "description": "Editorial issues or PRs that don't change the wire image or normative behavior.",
      "color": "006b75"
    }
  ],
  "issues": [
    {
      "number": 4,
      "id": "I_kwDOL3MllM6agc6U",
      "title": "Talk about TCP and SACK less",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/issues/4",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [
        "ianswett"
      ],
      "labels": [
        "Editorial"
      ],
      "body": "I believe the intent is to be as agnostic to the specific transport as possible, so implementers in QUIC or other transports can implement BBR as well.\r\n\r\nCurrently the draft has a number of references to TCP and SACK.  Some of them are needed for technical accuracy, but others could be removed or changed to more general language.",
      "createdAt": "2024-10-16T15:13:46Z",
      "updatedAt": "2024-10-21T15:36:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Great point. @ianswett  or @jbeshay -  do you have interest and cycles to take this on? :-) IMHO it would be good to have editorial changes from someone who is familiar with QUIC terminology, so the new text makes sense for both TCP and QUIC.\r\n",
          "createdAt": "2024-10-21T14:28:41Z",
          "updatedAt": "2024-10-21T14:28:41Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I was intending to tackle this, but I'm always happy to review someone else's PRs as well.",
          "createdAt": "2024-10-21T14:42:48Z",
          "updatedAt": "2024-10-21T14:42:48Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Great, thanks!\r\n",
          "createdAt": "2024-10-21T15:36:56Z",
          "updatedAt": "2024-10-21T15:36:56Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOL3MllM6dEqcL",
      "title": "Decide and document the BBR draft's stance on ECN",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/issues/7",
      "state": "OPEN",
      "author": "nealcardwell",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Today at the IETF 121 CCWG session, @martinduke asked about the BBR draft's stance on ECN.\r\n\r\nI agree that we should decide and document the BBR draft's stance on ECN.\r\n\r\nIn particular we should probably decide on and document the stance on both:\r\n\r\n+ RFC 3168 ECN\r\n+ L4S ECN\r\n\r\nFor the record, so the ideas are preserved and discussed, I'm pasting some of the CCWG session notes from [Borrowing from the session ](https://notes.ietf.org/notes-ietf-121-ccwg) :\r\n\r\n+ Martin Duke: What about ECT(0), which could be a smilair reaction to loss. Reply - would need to look at this.\r\n\r\n+ Michael Welzl: Following-up, there is ABE (RFC8511), which is a simple change, which uses a smaller backoff to an ECN mark using ECT(0), rather than the full L4S approach, but still with significant benefit. Reply - This is something to consider if we consider ECN.\r\n\r\ncc: @ianswett @jbeshay @renghardt @ekinnear @mattmathis @mwelzl",
      "createdAt": "2024-11-05T11:51:57Z",
      "updatedAt": "2024-11-05T18:38:30Z",
      "closedAt": null,
      "comments": [
        {
          "author": "chromi",
          "authorAssociation": "NONE",
          "body": "RFC-3168 requires a CE mark to be treated equivalently to a packet loss.  RFC-8511 modifies the *quantitative* extent to which this must be done, but essentially preserves the *qualitative* equivalency.\r\n\r\nBBR is a little special in that packet loss does not immediately cause a multiplicative-decrease reaction as in conventional window-based CCAs.  That is, BBR only considers packet loss to be a congestion indication above a certain threshold level.  Plain vanilla TCP with RFC-3168 support, however, only reports one CE mark per RTT.  If the BDP exceeds a few dozen segments, that would prevent RFC-3168 from signalling enough CE marks that, if treated strictly equivalent to packet loss, would meet the corresponding threshold and actually trigger a backoff.\r\n\r\nQUIC and SCTP don't have this limitation.  If multiple CE marks occur per RTT, they can report all of them \"precisely\" to the sender, and BBR would be able to meaningfully react to them as equivalents to loss.  There are also certain extensions to TCP which provide a similar capability.\r\n\r\nMy proposal to resolve this is straightforward:\r\n\r\n- If \"precise\" reporting of ECN marks is available, ie. multiple CE marks per RTT can be distinguished, then BBR should treat CE marks as equivalent to loss.\r\n- Otherwise, BBR should react to *single* CE marks in a manner more closely equivalent to standard CCA behaviour.  This could be by immediately and unconditionally entering the ProbeRTT state.\r\n",
          "createdAt": "2024-11-05T12:44:55Z",
          "updatedAt": "2024-11-05T12:44:55Z"
        },
        {
          "author": "martinduke",
          "authorAssociation": "NONE",
          "body": "I thought the ECT(0) thing would be straightforward, but Michael's comment\r\nmade it clear that is not a no-brainer. Therefore Neal's assessment that we\r\nshouldn't do anything without some experimentation and deployment is\r\nconvincing to me.\r\n\r\nSo I wouldn't hold this up based on someone willing to do the work,\r\nalthough (as Neal knows) I have some intent to some L4S-BBR testing. It may\r\nnot happen on a timetable useful for this draft.\r\n\r\nOn Tue, Nov 5, 2024 at 12:45\u202fPM Jonathan Morton ***@***.***>\r\nwrote:\r\n\r\n> RFC-3168 requires a CE mark to be treated equivalently to a packet loss.\r\n> RFC-8511 modifies the *quantitative* extent to which this must be done,\r\n> but essentially preserves the *qualitative* equivalency.\r\n>\r\n> BBR is a little special in that packet loss does not immediately cause a\r\n> multiplicative-decrease reaction as in conventional window-based CCAs. That\r\n> is, BBR only considers packet loss to be a congestion indication above a\r\n> certain threshold level. Plain vanilla TCP with RFC-3168 support, however,\r\n> only reports one CE mark per RTT. If the BDP exceeds a few dozen segments,\r\n> that would prevent RFC-3168 from signalling enough CE marks that, if\r\n> treated strictly equivalent to packet loss, would meet the corresponding\r\n> threshold and actually trigger a backoff.\r\n>\r\n> QUIC and SCTP don't have this limitation. If multiple CE marks occur per\r\n> RTT, they can report all of them \"precisely\" to the sender, and BBR would\r\n> be able to meaningfully react to them as equivalents to loss. There are\r\n> also certain extensions to TCP which provide a similar capability.\r\n>\r\n> My proposal to resolve this is straightforward:\r\n>\r\n>    - If \"precise\" reporting of ECN marks is available, ie. multiple CE\r\n>    marks per RTT can be distinguished, then BBR should treat CE marks as\r\n>    equivalent to loss.\r\n>    - Otherwise, BBR should react to *single* CE marks in a manner more\r\n>    closely equivalent to standard CCA behaviour. This could be by immediately\r\n>    and unconditionally entering the ProbeRTT state.\r\n>\r\n> \u2014\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/issues/7#issuecomment-2457074299>,\r\n> or unsubscribe\r\n> <https://github.com/notifications/unsubscribe-auth/AF2EYEKFHKSKQ2AGTWG7LTLZ7C4V3AVCNFSM6AAAAABRGLUIJSVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDINJXGA3TIMRZHE>\r\n> .\r\n> You are receiving this because you were mentioned.Message ID:\r\n> ***@***.***>\r\n>\r\n",
          "createdAt": "2024-11-05T13:22:44Z",
          "updatedAt": "2024-11-05T13:22:44Z"
        },
        {
          "author": "gorryfair",
          "authorAssociation": "NONE",
          "body": "I don't understand really why the simple approach in RFC 8511 can't just be used for ECT(0). I don't think we need to invent a new method - what is said there could be matched to BBR; I'd hope that any L4S device on path will also react to ECT(0) and mark as CE, therefore it would give you at least a helpful ECN reaction to a filling bottleneck",
          "createdAt": "2024-11-05T13:36:02Z",
          "updatedAt": "2024-11-05T13:36:02Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "@chromi points out an important issue here - indeed, with a threshold, the ability to convey only one mark per RTT can be problematic.\r\n\r\nI don't necessarily agree with the proposal though: if precise reporting is available, then why would you want to react to it as strongly as to loss? The RFC 8511 logic: \"ECN marks tells us that this comes from an AQM algorithm, and hence the queue is shorter\" is still true.",
          "createdAt": "2024-11-05T13:36:15Z",
          "updatedAt": "2024-11-05T13:36:15Z"
        },
        {
          "author": "chromi",
          "authorAssociation": "NONE",
          "body": "> @chromi points out an important issue here - indeed, with a threshold, the ability to convey only one mark per RTT can be problematic.\r\n> \r\n> I don't necessarily agree with the proposal though: if precise reporting is available, then why would you want to react to it as strongly as to loss? The RFC 8511 logic: \"ECN marks tells us that this comes from an AQM algorithm, and hence the queue is shorter\" is still true.\r\n\r\nBBR's response to loss is already very gentle, compared to NewReno or CUBIC:\r\n\r\n>    BBR searches for the maximum volume of data that can be sensibly\r\n>    placed in-flight in the network.  A key precondition is that the flow\r\n>    is actually trying robustly to find that operating point.  To\r\n>    implement this, when a flow is in ProbeBW, and an ACK covers data\r\n>    sent in one of the accelerating phases (REFILL or UP), and the ACK\r\n>    indicates that the loss rate over the past round trip exceeds the\r\n>    queue pressure objective, and the flow is not application limited,\r\n>    and has not yet responded to congestion signals from the most recent\r\n>    REFILL or UP phase, then the flow estimates that the volume of data\r\n>    it allowed in flight exceeded what matches the current delivery\r\n>    process on the path, and reduces BBR.inflight_hi:\r\n\r\n>    When encountering packet loss when the flow is not probing for\r\n>    bandwidth, the strategy is to gradually adapt to the current measured\r\n>    delivery process (the rate and volume of data that is delivered\r\n>    through the network path over the last round trip).  This applies\r\n>    generally: whether in fast recovery, RTO recovery, TLP recovery;\r\n>    whether application-limited or not.\r\n\r\n(The above is from \u00a7\u00a7 4.5.10.2-3.)\r\n\r\nIn fact, there's an argument that the response to a CE mark should be **more positive** than to loss.  Loss could have several causes, which motivates BBR's designed insensitivity to modest amounts of packet loss.  A CE mark is unambiguously a congestion signal.",
          "createdAt": "2024-11-05T13:51:20Z",
          "updatedAt": "2024-11-05T13:51:20Z"
        },
        {
          "author": "chromi",
          "authorAssociation": "NONE",
          "body": "Having read and understood a bit more of the specification than before, I think I can revise my proposal as follows:\r\n\r\n- When indication of a CE mark is reflected to the sender, BBR should immediately behave as though the packet loss rate exceeded the sensitivity threshold - that is, `BBRNoteLoss()` should be called and `IsInflightTooHigh()` should return `TRUE`.\r\n\r\nThis does not require any \"precise\" reflection of ECN marks, so it can be used with vanilla TCP.  The effect of a CE mark will be:\r\n\r\n- to terminate any bandwidth probe that BBR is carrying out, and\r\n- to pay more immediate attention to the \"delivery model\", which BBR uses to estimate the path characteristics, in adjusting the send rate and in-flight data volume for the immediate future.\r\n\r\nThis should be very easy to implement, and could also be one of the more straightforward possible modifications of BBR to test.",
          "createdAt": "2024-11-05T15:37:13Z",
          "updatedAt": "2024-11-05T15:37:13Z"
        },
        {
          "author": "mwelzl",
          "authorAssociation": "NONE",
          "body": "Ah, oh yes, you're right: since an ECN mark is, as you say, unambiguously a congestion signal, not immediately reacting to it (even just one signal/RTT) will cause delay and not help anyone. So this proposal of immediate reaction sounds right to me.",
          "createdAt": "2024-11-05T16:10:21Z",
          "updatedAt": "2024-11-05T16:10:21Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "I think it's important to document a recommended response to ECN in the draft, but I don't have a strong opinion on what that is as long as it performs well in real-world testing.",
          "createdAt": "2024-11-05T18:38:29Z",
          "updatedAt": "2024-11-05T18:38:29Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOL3MllM6dYrnQ",
      "title": "Do we need inflight_lo?",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/issues/8",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When looking at traces, I've found reasoning about when inflight_lo ends up being a limiting factor and when it's not is quite difficult.\r\n\r\nIn general, BBR attempts to create as accurate a model of the network path as possible.  Originally this was bandwidth and min_rtt, then extra acked for aggregation, then inflight_hi for the max BDP of the pipe.\r\n\r\nBecause BBR no longer does packet conservation, I realize there needs to be some sort of short term model, but the current one is quite complex and I'm hoping it could be simpler.\r\n\r\nIn the Google HTTP/3 implementation, we've done some YouTube experiments with ignoring inflight_lo entirely, and it didn't dramatically increase retransmit rate or RTT, and the QoE was slightly improved.  I don't have the data on hand, but it certainly didn't seem to break BBR and it made it much easier to reason about BBR's behavior.\r\n\r\nIt's possible that inflight_lo is critical to certain properties of BBR, in which case it'd be nice to document those.",
      "createdAt": "2024-11-07T09:59:55Z",
      "updatedAt": "2024-11-07T09:59:56Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOL3MllM6dYtXH",
      "title": "inflight_hi and inflight_lo are confusing names",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/issues/9",
      "state": "OPEN",
      "author": "ianswett",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Editorial"
      ],
      "body": "They're really inflight_longterm and inflight_shortterm or something along those lines.  Also, _hi can be lower than _lo, which is not at all obvious.\r\n\r\nTo be clear, I don't really like inflight_longterm and inflight_shortterm, but maybe inflight_long and inflight_short or something else?",
      "createdAt": "2024-11-07T10:02:42Z",
      "updatedAt": "2024-11-07T10:02:42Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "PR_kwDOL3MllM52vZRc",
      "title": "fix: correct misspelling \"que\" to \"queue\"",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/pull/1",
      "state": "MERGED",
      "author": "spmzt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request corrects a misspelling of the word 'queue'.",
      "createdAt": "2024-07-29T12:40:23Z",
      "updatedAt": "2024-07-29T13:06:34Z",
      "baseRepository": "ietf-wg-ccwg/draft-ietf-ccwg-bbr",
      "baseRefName": "main",
      "baseRefOid": "0f46affa058bdd125291f4a46098534f93cb4140",
      "headRepository": "spmzt/draft-cardwell-ccwg-bbr",
      "headRefName": "main",
      "headRefOid": "c3754e8f9c1e83a63352d658738e990c97e98a42",
      "closedAt": "2024-07-29T13:06:34Z",
      "mergedAt": "2024-07-29T13:06:34Z",
      "mergedBy": "nealcardwell",
      "mergeCommit": {
        "oid": "fbb5bc1beebd3507f12397f481833521f4c095d5"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 2,
      "id": "PR_kwDOL3MllM55Bily",
      "title": " Remove secs inside pseudocode of BBRPickProbeWait ",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/pull/2",
      "state": "CLOSED",
      "author": "spmzt",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "This pull request removes the non-pseudocode keyword 'secs'.\r\nI think the keyword 'secs' was unnecessary and not part of the pseudocode structure.",
      "createdAt": "2024-08-21T18:48:27Z",
      "updatedAt": "2024-10-21T16:03:33Z",
      "baseRepository": "ietf-wg-ccwg/draft-ietf-ccwg-bbr",
      "baseRefName": "main",
      "baseRefOid": "a9eb2f4f3649ce174503765d79565e1c6e65cb03",
      "headRepository": "spmzt/draft-cardwell-ccwg-bbr",
      "headRefName": "main",
      "headRefOid": "bd160b2ee252822f2cd34e948ba17a405d199b7e",
      "closedAt": "2024-10-21T16:03:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "spmzt",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Done.",
          "createdAt": "2024-08-24T23:42:39Z",
          "updatedAt": "2024-08-24T23:42:39Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Merged here, after rebasing to apply to the .md:\r\n\r\nhttps://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/commit/4159875aa93802a5603b5b75d61e28b70086bbd2\r\n\r\nAlso added you to the Acknowledgments:\r\n\r\nhttps://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/commit/871539f6c9e8561fc77578c37f6f33e890797c8f\r\n",
          "createdAt": "2024-10-21T16:03:33Z",
          "updatedAt": "2024-10-21T16:03:33Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL3MllM6Glt7N",
          "commit": {
            "abbreviatedOid": "975628f"
          },
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T20:16:08Z",
          "updatedAt": "2024-08-23T20:18:01Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "This \"que\" seems like it has already been fixed? Please rebase your patch series onto the latest version of the draft. Thanks!\r\n",
              "createdAt": "2024-08-23T20:16:08Z",
              "updatedAt": "2024-08-23T20:18:01Z"
            },
            {
              "originalPosition": 4,
              "body": "It seems like the removal of \"secs\" is the contribution here?\r\n\r\nCan you please rebase your commit onto the latest draft commits, and squash your commits into a single commit that makes this change? Thanks!\r\n",
              "createdAt": "2024-08-23T20:17:58Z",
              "updatedAt": "2024-08-23T20:18:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6Gl05r",
          "commit": {
            "abbreviatedOid": "975628f"
          },
          "author": "spmzt",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-08-23T20:37:13Z",
          "updatedAt": "2024-08-23T20:37:13Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Ok",
              "createdAt": "2024-08-23T20:37:13Z",
              "updatedAt": "2024-08-23T20:37:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6NSCRY",
          "commit": {
            "abbreviatedOid": "bd160b2"
          },
          "author": "ianswett",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-15T18:59:53Z",
          "updatedAt": "2024-10-15T18:59:53Z",
          "comments": []
        }
      ]
    },
    {
      "number": 3,
      "id": "PR_kwDOL3MllM58OHZQ",
      "title": "Language clarifications",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/pull/3",
      "state": "MERGED",
      "author": "jbeshay",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- Minor clarifications to the prose\r\n- Removes explicit references to Youtube",
      "createdAt": "2024-09-20T22:35:22Z",
      "updatedAt": "2024-10-21T21:57:31Z",
      "baseRepository": "ietf-wg-ccwg/draft-ietf-ccwg-bbr",
      "baseRefName": "main",
      "baseRefOid": "871539f6c9e8561fc77578c37f6f33e890797c8f",
      "headRepository": "jbeshay/draft-ietf-ccwg-bbr",
      "headRefName": "20240920",
      "headRefOid": "acbd8ca5e1f58ba8c23ae8d392bccb0d378ea6a3",
      "closedAt": "2024-10-21T21:57:23Z",
      "mergedAt": "2024-10-21T21:57:23Z",
      "mergedBy": "jbeshay",
      "mergeCommit": {
        "oid": "b912be6cbc3ffec98692d4acd5da9067f3237611"
      },
      "comments": [
        {
          "author": "jbeshay",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I am going to redo this on top of the markdown version.\r\ncc @nealcardwell @ianswett ",
          "createdAt": "2024-10-17T04:41:48Z",
          "updatedAt": "2024-10-17T04:41:48Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, this 4-commit version with purely editorial changes looks great to merge now. Thanks!\r\n",
          "createdAt": "2024-10-21T20:27:21Z",
          "updatedAt": "2024-10-21T20:27:21Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL3MllM6KcVOy",
          "commit": {
            "abbreviatedOid": "9571b36"
          },
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! Mostly looks great. I had one question and one quick suggestion.\r\n\r\ncc: @ianswett\r\n",
          "createdAt": "2024-09-23T15:42:24Z",
          "updatedAt": "2024-09-23T15:55:06Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "I agree it would be great to simplify this ack_phase stuff... But AFAICT this has a bug: in a particular ProbeBW_DOWN episode, before a round trip in ProbeBW_DOWN elapses (before BBR.round_start becomes true),  BBRIsTimeToCruise() may return true if inflight is less than the estimated BDP. So this expression may never be true, and the BBRAdvanceMaxBwFilter() may never be called. WDYT?\r\n",
              "createdAt": "2024-09-23T15:42:24Z",
              "updatedAt": "2024-09-23T15:55:06Z"
            },
            {
              "originalPosition": 5,
              "body": "Looks like this 0.35 value occurs a second time, lower in the text:\r\n\r\n    It uses a pacing_gain of BBRDrainPacingGain = 0.35\r\n\r\nLet's change that one as well. Perhaps we should remove the discussion of the exactly value in that other spot, so we don't have this kind of potential disagreement in the text in the future. How about:\r\n\r\nold:\r\n\r\n      It uses a pacing_gain of BBRDrainPacingGain = 0.35, chosen...\r\n\r\nproposed:\r\n\r\n      It uses a pacing_gain of BBRDrainPacingGain, with a value chosen ...\r\n",
              "createdAt": "2024-09-23T15:47:49Z",
              "updatedAt": "2024-09-23T15:55:06Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6KomE2",
          "commit": {
            "abbreviatedOid": "9d31d2e"
          },
          "author": "jbeshay",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-09-24T17:11:16Z",
          "updatedAt": "2024-09-24T17:11:17Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Good point. One way to avoid the bug is to advance the cycle when entering ProbeBW_DOWN if the transport isn't app limited. That's the approach I've taken in mvfst. ",
              "createdAt": "2024-09-24T17:11:17Z",
              "updatedAt": "2024-09-24T17:11:17Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6NSCzk",
          "commit": {
            "abbreviatedOid": "9571b36"
          },
          "author": "ianswett",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "TBH, I think sent and transmitted are equivalent and sent is shorter, so unless there's a clear definition of one vs the other, I prefer sent.",
          "createdAt": "2024-10-15T19:01:04Z",
          "updatedAt": "2024-10-16T02:00:46Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "```suggestion\r\n<t>Variables for connection state (C), per-packet state (P), or per-ACK rate sample (rs) that are not defined below are defined in <xref target=\"delivery-rate-samples\"/> \"Delivery Rate Samples\".</t>\r\n```",
              "createdAt": "2024-10-15T19:01:04Z",
              "updatedAt": "2024-10-16T02:00:46Z"
            },
            {
              "originalPosition": 43,
              "body": "```suggestion\r\n<t>BBR's state machine uses two control mechanisms: the pacing_gain and the cwnd. Primarily, it uses the pacing_gain (see the \"Pacing Rate\" section), which controls how fast packets are sent relative to BBR.bw. A pacing_gain &gt; 1 decreases inter-packet time and increases inflight. A pacing_gain &lt; 1 has the opposite effect, increasing inter-packet time and while aiming to decrease inflight. The cwnd is sufficiently larger than the BDP to allow the higher pacing gain to accumulate more packets in flight. Only if the state machine needs to quickly reduce inflight to a particular absolute value, it uses the cwnd.</t>\r\n```",
              "createdAt": "2024-10-16T01:47:21Z",
              "updatedAt": "2024-10-16T02:00:46Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\n<t>Upon starting a full pipe detection process (either on startup or when probing for an increase in bandwidth), the following steps are taken:</t>\r\n```",
              "createdAt": "2024-10-16T01:47:56Z",
              "updatedAt": "2024-10-16T02:00:46Z"
            },
            {
              "originalPosition": 62,
              "body": "Maybe we should define what a 'round' is above and use that here and elsewhere?",
              "createdAt": "2024-10-16T01:48:43Z",
              "updatedAt": "2024-10-16T02:00:46Z"
            },
            {
              "originalPosition": 62,
              "body": "I thought the 3 round number was due to a number of issues, including receive window auto-tuning.  This text seems to be assuming a certain auto-tuning behavior, which I'm a bit uncomfortable with given it's implementation dependent.\r\n\r\n```suggestion\r\n<t>BBR waits three packet-timed round trips to have solid evidence that the sender is not detecting a delivery-rate plateau that was temporarily imposed by the receive window or temporary congestion. Allowing three rounds provides time for the receiver's receive-window auto-tuning to open up the receive window and for the BBR sender to realize that BBR.max_bw should be higher: in the first round the receive-window auto-tuning algorithm grows the receive window; in the second round the sender fills the higher receive window; in the third round the sender gets higher delivery-rate samples. This three-round threshold was validated by experimental data.</t>\r\n```",
              "createdAt": "2024-10-16T01:51:54Z",
              "updatedAt": "2024-10-16T02:00:46Z"
            },
            {
              "originalPosition": 125,
              "body": "```suggestion\r\n<t>Delivery rate samples are generated upon receiving ACKs; Losing an ACK results in losing the delivery rate sample, and instead generating a delivery rate sample from a subsequent ACK. Lost ACKs can underestimate the delivery rate due the artificially inflated \"rs.interval\". The impact of this effect is mitigated using the BBR.max_bw filter. </t>\r\n```",
              "createdAt": "2024-10-16T01:59:15Z",
              "updatedAt": "2024-10-16T02:00:46Z"
            },
            {
              "originalPosition": 134,
              "body": "This is TCP centric, FYI.  Also, I don't think we care about the performance of BBR without SACK?",
              "createdAt": "2024-10-16T02:00:33Z",
              "updatedAt": "2024-10-16T02:00:46Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6NVEJt",
          "commit": {
            "abbreviatedOid": "9571b36"
          },
          "author": "jbeshay",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T03:36:55Z",
          "updatedAt": "2024-10-16T03:36:55Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "We could remove the description of the specific receive window tuning behavior.\r\n```suggestion\r\n<t>BBR waits three packet-timed round trips to have reasonable evidence that the sender is not detecting a delivery-rate plateau that was temporarily imposed by congestion or receive-window auto-tuning. This three-round threshold was validated by experimental data to allow the receiver the chance to grow its receive window.</t>\r\n```",
              "createdAt": "2024-10-16T03:36:55Z",
              "updatedAt": "2024-10-16T03:36:56Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6NVEjI",
          "commit": {
            "abbreviatedOid": "9571b36"
          },
          "author": "jbeshay",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-16T03:39:13Z",
          "updatedAt": "2024-10-16T03:39:13Z",
          "comments": [
            {
              "originalPosition": 125,
              "body": "I will use your suggestion, changing the casing of `losing` after `ACKs;`\r\n```suggestion\r\n<t>Delivery rate samples are generated upon receiving ACKs; losing an ACK results in losing the delivery rate sample, and instead generating a delivery rate sample from a subsequent ACK. Lost ACKs can underestimate the delivery rate due the artificially inflated \"rs.interval\". The impact of this effect is mitigated using the BBR.max_bw filter. </t>\r\n```",
              "createdAt": "2024-10-16T03:39:13Z",
              "updatedAt": "2024-10-16T03:39:13Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6ODeZI",
          "commit": {
            "abbreviatedOid": "acbd8ca"
          },
          "author": "ianswett",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Text LG, but we should decide if we want to impose the line limits I've seen in other Github IETF projects.",
          "createdAt": "2024-10-21T20:46:22Z",
          "updatedAt": "2024-10-21T20:47:01Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "The text LG, but usually we reflow markdown to ~80 character lines, at least in my experience.",
              "createdAt": "2024-10-21T20:46:22Z",
              "updatedAt": "2024-10-21T20:47:01Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6OD1rG",
          "commit": {
            "abbreviatedOid": "acbd8ca"
          },
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T21:49:37Z",
          "updatedAt": "2024-10-21T21:49:37Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "I prefer 80 character lines as well. It should make it easier to have smaller, easy-to-review diffs. And make it easier to view/edit as well.\r\n\r\n@jbeshay - if you have time to reformat to 80 characters, that's great.\r\n\r\nSince we're on a deadline, I'm OK with merging this version now and I can reformat as a follow-up if you want.\r\n\r\n",
              "createdAt": "2024-10-21T21:49:37Z",
              "updatedAt": "2024-10-21T21:49:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOL3MllM6OD3zT",
          "commit": {
            "abbreviatedOid": "acbd8ca"
          },
          "author": "jbeshay",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-21T21:56:54Z",
          "updatedAt": "2024-10-21T21:56:55Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Sounds good. I'll merge this now then. I will push the reformat to 80 characters later tonight.",
              "createdAt": "2024-10-21T21:56:55Z",
              "updatedAt": "2024-10-21T21:56:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOL3MllM5_WnhG",
      "title": "Remove BBR.ack_phase from pseudocode",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/pull/5",
      "state": "OPEN",
      "author": "jbeshay",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "We don't need to explicitly track the ack_phase in order to advance MaxBWFilter. Instead, we can advance it when entering ProbeBW_Down.\r\n\r\nThis logic is currently used in Mvfst. ",
      "createdAt": "2024-10-21T17:14:29Z",
      "updatedAt": "2024-10-21T17:14:29Z",
      "baseRepository": "ietf-wg-ccwg/draft-ietf-ccwg-bbr",
      "baseRefName": "main",
      "baseRefOid": "871539f6c9e8561fc77578c37f6f33e890797c8f",
      "headRepository": "jbeshay/draft-ietf-ccwg-bbr",
      "headRefName": "remove_ack_phase",
      "headRefOid": "ee98c12ad6f0e93153656218a7df1b1ef92618d7",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 6,
      "id": "PR_kwDOL3MllM5_WrsD",
      "title": "Use consistent value for drain pacing gain which matches derivation doc",
      "url": "https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/pull/6",
      "state": "OPEN",
      "author": "jbeshay",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The drain gain value is inconsistent. The derivation doc linked (https://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_drain_gain.pdf) suggests using 0.5 and that's the value referenced in the table under (Summary of Control Behavior in the State Machine).  0.35 (~ 1 / StartupPacingGain) is used in a couple of other places.\r\n\r\nThis PR changes it to 0.5 everywhere. \r\n\r\nExisting implementations are using 0.35 ([Linux TCP](https://github.com/google/bbr/blob/v3/net/ipv4/tcp_bbr.c#L221C46-L221C51), [Quiche](https://github.com/google/quiche/blob/73107195dfbe8f0a531d3e2f052c9f2e15ec0e3c/quiche/quic/core/congestion_control/bbr2_misc.h#L111), [Mvfst](https://github.com/facebook/mvfst/blob/main/quic/congestion_control/Bbr2.cpp#L27)). The 0.5 value can be regarded as an upper bound. \r\n\r\nThis PR will keep the value consistent in the draft while we test the impact of the changing it to 0.5.",
      "createdAt": "2024-10-21T17:24:45Z",
      "updatedAt": "2024-11-04T15:59:55Z",
      "baseRepository": "ietf-wg-ccwg/draft-ietf-ccwg-bbr",
      "baseRefName": "main",
      "baseRefOid": "bbc5137f505b65c4063296e52f13d930ccfa3eb8",
      "headRepository": "jbeshay/draft-ietf-ccwg-bbr",
      "headRefName": "drain_gain",
      "headRefOid": "7a56fb259117a8ccac4868cf50fc44290a7aa169",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "As one data point, we have performance A/B experiment data from Linux TCP YouTube experiments. The main performance changes were:\r\n\r\n+ 0.5x has slightly slower video play start-up\r\n+ 0.5x has slightly more rebuffers\r\n",
          "createdAt": "2024-11-01T17:04:44Z",
          "updatedAt": "2024-11-01T17:04:44Z"
        },
        {
          "author": "ianswett",
          "authorAssociation": "NONE",
          "body": "As with all things in BBR, one change can be better or worse depending upon another.  Do we think there's a chance exit from STARTUP will get faster?  If so, draining the pipe quickly might be less important?\r\n\r\nAlternatively, we could adopt the stance that the drain pacing gain should be based on the STARTUP pacing gain, not the CWND gain, because ideally BBR is largely rate/pacing limited and not CWND limited?",
          "createdAt": "2024-11-04T00:45:07Z",
          "updatedAt": "2024-11-04T00:45:07Z"
        },
        {
          "author": "jbeshay",
          "authorAssociation": "CONTRIBUTOR",
          "body": ">  Do we think there's a chance exit from STARTUP will get faster? If so, draining the pipe quickly might be less important?\r\n\r\nChanging the drain pacing gain is used after we've already decided to exit startup, so I don't see how this change can impact startup.\r\n\r\n> Alternatively, we could adopt the stance that the drain pacing gain should be based on the STARTUP pacing gain, not the CWND gain\r\n\r\nThe cwnd gain is used in the referenced [derivation doc](https://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_drain_gain.pdf) in the assumption about the inflight volume at the beginning of DRAIN: \r\n```\r\nstarting_inflight = BBRStartupCwndGain * bw * min_rtt\r\n```\r\nSwitching this to the StartupPacingGain will give us a value for inflight that Startup can't actually achieve, so we'll try to drain more aggressively (0.35 vs. 0.5) and end up draining in under 1 rtt consistently. My hypothesis is that the shorter drain duration is probably behind the better startup and lower rebuffers in test that we lose with 0.5 due to longer drain.\r\n\r\n> because ideally BBR is largely rate/pacing limited and not CWND limited?\r\n\r\nOn this, I think it applies at the beginning of Startup and throughout ProbeBW. But when Startup has reached the delivery rate plateau, BBR should be cwnd limited since StartupPacingGain > StartupCwndGain. Is my reasoning correct here?",
          "createdAt": "2024-11-04T15:38:04Z",
          "updatedAt": "2024-11-04T15:38:04Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "I (@nealcardwell) said:\r\n> As one data point, we have performance A/B experiment data from Linux TCP YouTube experiments. The main performance changes were:\r\n\r\nLooking again at these results, Ian has pointed out that it's unclear if those results were statistically significant.\r\n\r\nI've updated the slides to say:\r\n\r\n```\r\n+ Have some performance A/B experiment data from Linux TCP YouTube experiments:\r\n  + Unclear if there are statistically significant performance regressions\r\n  + Would like to re-run an experiment to ensure there are no regressions\r\n```\r\n\r\n@ianswett said:\r\n> Alternatively, we could adopt the stance that the drain pacing gain should be based on the STARTUP pacing gain, not the CWND gain, because ideally BBR is largely rate/pacing limited and not CWND limited?\r\n\r\nI'm pretty sure that the pacing gain in Drain should be 1/startup_cwnd_gain, based on:\r\n\r\n(1) the derivation:\r\nhttps://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_drain_gain.pdf\r\n\r\n(2) the traces, where we see clearly that in STARTUP typically there is a large standing queue for several round trips, whose magnitude is controlled by startup_cwnd_gain:\r\nhttps://www.ietf.org/proceedings/97/slides/slides-97-iccrg-bbr-congestion-control-02.pdf#page=16\r\n\r\n---\r\n\r\nOverall, personally I'm strongly inclined to change the drain pacing gain from 0.346 to 0.5 for a number of reasons:\r\n\r\n(1) consistency with the derivation:\r\nhttps://github.com/google/bbr/blob/master/Documentation/startup/gain/analysis/bbr_drain_gain.pdf\r\n\r\n(2) simplicity (1/2 is simpler than a 0.346 that would be a hang-over derived from an earlier BBR design parameter that's no longer used)\r\n\r\n(3) using 1/2 presumably has a significantly lower risk of stalls/rebuffers if the ACK stream dries up;  if the ACK stream dries up we presumably would rather have the pacing rate set to 0.5*estimated_bandwidth\r\n than 0.34*estimated_bandwidth.\r\n\r\nI would just like to run another A/B experiment to directly compare 0.346 with 0.5 to ensure there is no regression, before \"finalizing\" the 0.5 value.\r\n",
          "createdAt": "2024-11-04T15:41:55Z",
          "updatedAt": "2024-11-04T15:41:55Z"
        },
        {
          "author": "nealcardwell",
          "authorAssociation": "COLLABORATOR",
          "body": "[BTW, my update https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/pull/6#issuecomment-2455049496 crossed with Joseph's update https://github.com/ietf-wg-ccwg/draft-ietf-ccwg-bbr/pull/6#issuecomment-2455039635 ... :-) ]\r\n\r\n>  But when Startup has reached the delivery rate plateau, BBR should be cwnd limited since StartupPacingGain > StartupCwndGain. Is my reasoning correct here?\r\n\r\nI believe the reasoning would be: when Startup has reached the delivery rate plateau, BBR should be cwnd limited since: \r\n\r\nStartupPacingGain > 1, which means the sending rate is greater than the delivery rate, so that a queue will accumulate at the bottleneck link and grow until inflight reaches cwnd, and the magnitude of the flow's contribution to the queue will be roughly: cwnd - true_BDP ~= startup_cwnd_gain*estimated_BDP - true_BDP, so the magnitude of the queue will be in proportion to startup_cwnd_gain.\r\n\r\n",
          "createdAt": "2024-11-04T15:59:54Z",
          "updatedAt": "2024-11-04T15:59:54Z"
        }
      ],
      "reviews": [
        {
          "id": "PRR_kwDOL3MllM6OEkCF",
          "commit": {
            "abbreviatedOid": "c7d7d37"
          },
          "author": "ianswett",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "LGTM, minus the very long line.",
          "createdAt": "2024-10-22T01:11:15Z",
          "updatedAt": "2024-10-22T01:11:26Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Please reflow this",
              "createdAt": "2024-10-22T01:11:16Z",
              "updatedAt": "2024-10-22T01:11:26Z"
            }
          ]
        }
      ]
    }
  ]
}